# BrandLab | Frontend (React + Vite)

This repository contains the BrandLab frontend application: a TypeScript + React single-page app built with Vite and styled with Tailwind CSS. The app integrates with BrandLab backend services to create campaigns, upload product images, request LLM-generated variation plans, and view images generated by Bria's FIBO model. Authentication and storage use Supabase.

This README covers: quickstart, environment variables, local development, building for production, how the frontend integrates with the backend and Bria flow, and pointers to main source files.

Requirements
- Node.js 18+ and npm (or yarn) installed
- Access to the BrandLab backend (running locally or deployed)
- Supabase project for auth and storage (optional for local dev but recommended)

Quickstart

1. Install dependencies and start the dev server:

```bash
npm install
npm run dev
```

2. Open the app in your browser (Vite will show the local URL).

Environment variables
Create a `.env` file based on `.env.example` with at least the following keys:

- `VITE_SUPABASE_URL` — Supabase project URL
- `VITE_SUPABASE_ANON_KEY` — Supabase public anon key
- `VITE_API_BASE_URL` — Base URL for the BrandLab backend API (e.g. http://localhost:8000)

Local development notes
- The Supabase client is initialized in `Frontend-fibo-hackathon/src/lib/supabaseClient.ts`.
- Authentication flows are handled by `src/services/authService.ts` and UI components in `src/components`.
- The canvas and gallery live under `src/components/organisms` and `src/components/panels`.

Running tests and linting

```bash
# run any existing test runner (if configured)
npm run test
# lint and format
npm run lint
```

Building for production

```bash
npm run build
npm run preview   # preview production build locally
```

Frontend ↔ Backend integration (example)

The frontend calls BrandLab backend endpoints to create campaigns, upload products, request plan generation, and execute plans. The primary backend base URL is set via `VITE_API_BASE_URL`.

Example: create a campaign (fetch)

```ts
// src/services/brandlabApi.ts (example)
const API_BASE = import.meta.env.VITE_API_BASE_URL;

export async function createCampaign(payload: object) {
	const res = await fetch(`${API_BASE}/api/v1/campaigns`, {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify(payload),
	});
	if (!res.ok) throw new Error(await res.text());
	return res.json();
}

// Usage example
// createCampaign({ name: 'Summer Collection', brand_guidelines: { primary_color: 'coral pink' } })
```

Example: upload a product image (multipart form)

```ts
export async function uploadProduct(campaignId: string, file: File) {
	const API_BASE = import.meta.env.VITE_API_BASE_URL;
	const form = new FormData();
	form.append('file', file);
	const res = await fetch(`${API_BASE}/api/v1/campaigns/${campaignId}/upload-product`, {
		method: 'POST',
		body: form,
	});
	if (!res.ok) throw new Error(await res.text());
	return res.json();
}
```

Triggering plan generation (LLM agent)

```ts
export async function requestPlan(campaignId: string, body: { product_id: string; variations_count: number }) {
	const API_BASE = import.meta.env.VITE_API_BASE_URL;
	const res = await fetch(`${API_BASE}/api/v1/campaigns/${campaignId}/generate-plan`, {
		method: 'POST',
		headers: { 'Content-Type': 'application/json' },
		body: JSON.stringify(body),
	});
	if (!res.ok) throw new Error(await res.text());
	return res.json();
}
```

How the Bria FIBO flow appears to the frontend

- The frontend never calls Bria directly. Instead, it uploads product images and requests plan generation or execution via the BrandLab backend. The backend owns the `BRIA_API_KEY` and calls Bria's FIBO endpoints. This keeps secrets off the client and centralizes request/response handling.
- Example flow: user uploads product -> frontend sends file to `/upload-product` -> user requests plan -> frontend calls `/generate-plan` -> backend returns a plan with structured prompts -> user reviews and triggers `/execute` -> backend executes FIBO calls and returns image URLs.

Example UI usage: displaying a generated image

```tsx
// In a React component
const [imageUrl, setImageUrl] = useState<string | null>(null);

useEffect(() => {
	// after executing a plan, backend returns an item with `image_url`
	setImageUrl(result.image_url);
}, [result]);

return imageUrl ? <img src={imageUrl} alt="Generated variation" /> : null;
```

Existing helper files and components

- `src/lib/supabaseClient.ts` — Supabase client for storage and auth.
- `src/services/authService.ts` — Sign-in / sign-up helpers.
- `src/services/geminiService.ts` — agent/LLM integrations used by UI controls.
- `src/components/organisms` — Canvas and primary layout components.

Deployment notes

- Build the app (`npm run build`) and deploy the `dist` directory to any static hosting (Vercel, Netlify, S3+CloudFront).
- Ensure `VITE_API_BASE_URL` points to the production backend.
- Add proper CORS and cookie/storage settings for Supabase and backend when deploying.

Development and contribution

- Code style is TypeScript + Tailwind CSS. Keep components small and unit-testable.
- Add tests for critical services in `src/services` and UI snapshot tests for major components.

Troubleshooting

- If image uploads fail, verify `VITE_SUPABASE_URL` and `VITE_SUPABASE_ANON_KEY` are correct and that the Supabase CORS settings allow requests from your frontend origin.
- If backend calls fail, confirm `VITE_API_BASE_URL` is correct and that the backend is running.

Files to inspect for integration logic

- [src/lib/supabaseClient.ts](Frontend-fibo-hackathon/src/lib/supabaseClient.ts)
- [src/services/authService.ts](Frontend-fibo-hackathon/src/services/authService.ts)
- [src/services/geminiService.ts](Frontend-fibo-hackathon/src/services/geminiService.ts)
- [src/components/organisms/canvas/MainCanvas.tsx](Frontend-fibo-hackathon/src/components/organisms/canvas/MainCanvas.tsx)

## BrandLab team

- Tavotsu -> `Backend, Deployment & Debugging`
- Zenith-AB -> `Backend & AI integration`
- Krist0-afk -> `Frontend`
- Elchacra -> `Testing & Debugging`
- ManuelADMN -> `AI integration`

